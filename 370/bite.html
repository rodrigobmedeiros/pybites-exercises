<p>In the previous two Bites you have annotated small pieces of code with type hints. In this Bite, instead of dealing with isolated and (sometimes) less meaningful chunks of code, you will start working on a real, functional code base for some cool linear algebra (don't show your excitement that much!).</p>
<p>If you are new to typing / type annotations, maybe you want to read the <a href="https://pybit.es/articles/code-better-with-type-hints-part-1/">Pybites article series about typing</a> first or in an addition to this learning path. Of course, you can always ask the official documentation for help, though. There is the documentation of the <a href="https://docs.python.org/3/library/typing.html" target="_blank" rel="noopener">typing module</a> (be aware of the correct Python version that you are using!) as well as a lot of Python Enhancement Proposals (PEP), also linked in the module's documentation. Given that the official documentation, and PEPs in particular, are often not the easiest reading material, I found the <a href="https://mypy.readthedocs.io/en/stable/index.html" target="_blank" rel="noopener">mypy documentation</a>&nbsp;a very good starting place.</p>
<h3>The <code>Vector</code> class</h3>
<p>You do not have to understand every implementation detail! However, if you want to refresh your knowledge about linear algebra, have a look at <a href="https://pythonnumericalmethods.berkeley.edu/notebooks/chapter14.01-Basics-of-Linear-Algebra.html" target="_blank" rel="noopener">Basics of Linear Algebra</a>. There you can learn about how to do things properly with <code>numpy</code>, too.</p>
<p>The following REPL example will show you examples of how you can use the <code>Vector</code> class that you are expected to annotate.</p>
<pre>v = Vector(1, 1, 1)<br />print(v)<br />&gt;&gt;&gt; [1 1 1]<br />print(v.__repr__())<br />&gt;&gt;&gt; Vector(x=1, y=1, z=1)<br />print(len(v))<br />&gt;&gt;&gt; 3<br />print(v.x, v.y, v.z)<br />&gt;&gt;&gt; 1 1 1&nbsp;<br />print(v[0], v[1], v[2])<br />&gt;&gt;&gt; 1 1 1<br />print(v())<br />&gt;&gt;&gt; (1, 1, 1)<br />print(v.norm(1), v.norm(2), v.norm(3))<br />&gt;&gt;&gt; 3.0 1.7320508075688772 1.4422495703074083<br /><br />w = Vector.from_list([1, 2, 3])<br />print(w)<br />&gt;&gt;&gt; [1 2 3]<br /><br />print(v + w)<br /><span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">&gt;&gt;&gt; [2 3 4]<br /></span>print(w + v)<br />&gt;&gt;&gt; [2 3 4]<br />print(w - v)<br />&gt;&gt;&gt; [0 1 2]<br /><br />print(v * 2)<br />&gt;&gt;&gt; [2.0 2.0 2.0]<br />print(2 * v)<br />&gt;&gt;&gt; [2.0 2.0 2.0]<br />print(v * 0.5)<br />&gt;&gt;&gt; [0.5 0.5 0.5]<br />print(v * w)<br />&gt;&gt;&gt; 6<br />print(w * v)<br />&gt;&gt;&gt; 6<br /><br />print(v.iscollinear(w))<br />&gt;&gt;&gt; False<br />print(v.iscollinear(2 * v))<br />&gt;&gt;&gt; True<br /><br />print(Vector(10, 9, 3).angle(Vector(2, 5, 12)))<br />&gt;&gt;&gt; 0.979924710443726<br /><br />v = Vector(0, 3, 2)<br />w = Vector(4, 1, 1)<br />u = Vector(0, -2, 0)<br />x = 3 * v - 2 * w + 4 * u<br />print(x)<br />&gt;&gt;&gt; [-8.0 -1.0 4.0]</pre>
<h3>Your Task</h3>
<p>In this Bite, you have to add type hints to all methods of the <code>Vector</code> class. Here are a few marks:</p>
<p>- When you need the type of the class itself, you can use a quoted type, see <a href="https://peps.python.org/pep-0484/#forward-references" target="_blank" rel="noopener">Forward references</a>. There are other possibilities (for example <code>Self</code> with 3.11), but we are just getting started, aren't we.</p>
<p>- The <code>Vector</code> class will work both with integers and floats. Does that mean you always have to annotate both types? You don't, thanks to the <a href="https://peps.python.org/pep-0484/#the-numeric-tower" target="_blank" rel="noopener">numeric tower</a>. In short: Although <code>int</code> is <strong>not</strong> a subclass of <code>float</code>, the type <code>float</code> also accepts the type <code>int</code>. So just stick with <code>float</code> for now.</p>
<p>- Please annotate all methods, dunder methods included.</p>
<p>- The dunder method <code>__mul__</code> can return two different things, depending on the passed attribute's type. You will learn about a better way to do this, but for now, stick with <code>typing.Union</code>.</p>
<p><em><strong>Note</strong>:&nbsp;</em><em>please be patient if the platform does not instantly show the test results,</em><em style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">&nbsp;the last final test (</em><em style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">test_mypy_report) takes at least 10 seconds to run. However, in return we are not limited to</em><em>&nbsp;checking concrete types, allowing multiple options in your code submissions.&nbsp;</em><em style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;">Thanks.&nbsp;</em></p>